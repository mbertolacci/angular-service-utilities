// Generated by CoffeeScript 1.3.3
(function() {

  describe('angular-service-utilities', function() {
    beforeEach(module('serviceUtilities'));
    beforeEach(module(function($exceptionHandlerProvider) {
      return $exceptionHandlerProvider.mode('log');
    }));
    describe('$compose', function() {
      var $compose, $exceptionHandler, $rootScope;
      $compose = null;
      $rootScope = null;
      $exceptionHandler = null;
      beforeEach(inject(function(_$rootScope_, _$compose_, _$exceptionHandler_) {
        $rootScope = _$rootScope_;
        $compose = _$compose_;
        $exceptionHandler = _$exceptionHandler_;
        return jasmine.Clock.useMock();
      }));
      it('should $compose.compose scopes after bidirectionally transmit digests', function() {
        var $scope1, $scope2, watchPropertySpy1, watchPropertySpy2, watchSpy1, watchSpy2, watchSpyRoot;
        $scope1 = $rootScope.$new(true);
        $scope2 = $rootScope.$new(true);
        $scope2.safe = 'as houses';
        $compose.compose($scope2, $scope1, 'other');
        watchSpyRoot = jasmine.createSpy('watchSpyRoot');
        watchSpy1 = jasmine.createSpy('watchSpy1');
        watchPropertySpy1 = jasmine.createSpy('watchPropertySpy1');
        watchSpy2 = jasmine.createSpy('watchSpy2');
        watchPropertySpy2 = jasmine.createSpy('watchPropertySpy2');
        $rootScope.$watch(watchSpyRoot);
        $scope1.$watch('other.safe', watchPropertySpy1);
        $scope1.$watch(watchSpy1);
        $scope2.$watch(watchSpy2);
        $scope2.$watch('safe', watchPropertySpy2);
        jasmine.Clock.tick(1);
        expect(watchSpyRoot).not.toHaveBeenCalled();
        expect(watchPropertySpy1.calls.length).toEqual(1);
        expect(watchSpy1.calls.length).toEqual(2);
        expect(watchSpy2).not.toHaveBeenCalled();
        expect(watchPropertySpy2).not.toHaveBeenCalled();
        expect($scope1.other).toEqual($scope2);
        expect($scope2.safe).toEqual($scope1.other.safe);
        $scope2.$digest();
        jasmine.Clock.tick(1);
        watchSpyRoot.reset();
        watchSpy1.reset();
        watchSpy2.reset();
        watchPropertySpy1.reset();
        watchPropertySpy2.reset();
        $scope1.other.safe = 'as trousers';
        $scope1.$digest();
        jasmine.Clock.tick(1);
        expect(watchSpyRoot).not.toHaveBeenCalled();
        expect(watchPropertySpy1).toHaveBeenCalled();
        expect(watchSpy1).toHaveBeenCalled();
        expect(watchSpy2).toHaveBeenCalled();
        expect(watchPropertySpy2).toHaveBeenCalled();
        expect($scope1.other).toEqual($scope2);
        expect($scope2.safe).toEqual($scope1.other.safe);
        watchSpyRoot.reset();
        watchSpy1.reset();
        watchSpy2.reset();
        watchPropertySpy1.reset();
        watchPropertySpy2.reset();
        jasmine.Clock.tick(1);
        expect(watchPropertySpy1).not.toHaveBeenCalled();
        expect(watchSpy1).not.toHaveBeenCalled();
        expect(watchSpy2).not.toHaveBeenCalled();
        return expect(watchPropertySpy2).not.toHaveBeenCalled();
      });
      it('should $compose.composeProperty after bidirectionally transmit digests', function() {
        var $scope1, $scope2, watchPropertySpy1, watchPropertySpy2, watchSpyRoot;
        $scope1 = $rootScope.$new(true);
        $scope2 = $rootScope.$new(true);
        $scope2.safe = 'as houses';
        $compose.composeProperty($scope2, 'safe', $scope1, 'safe');
        watchSpyRoot = jasmine.createSpy('watchSpyRoot');
        watchPropertySpy1 = jasmine.createSpy('watchPropertySpy1');
        watchPropertySpy2 = jasmine.createSpy('watchPropertySpy2');
        $rootScope.$watch(watchSpyRoot);
        $scope1.$watch('safe', watchPropertySpy1);
        $scope2.$watch('safe', watchPropertySpy2);
        jasmine.Clock.tick(1);
        expect(watchSpyRoot).not.toHaveBeenCalled();
        expect(watchPropertySpy1).toHaveBeenCalled();
        expect(watchPropertySpy2).not.toHaveBeenCalled();
        expect($scope1.safe).toEqual($scope2.safe);
        watchSpyRoot.reset();
        watchPropertySpy1.reset();
        watchPropertySpy2.reset();
        $scope1.safe = 'as trousers';
        $scope1.$digest();
        jasmine.Clock.tick(1);
        expect(watchSpyRoot).not.toHaveBeenCalled();
        expect(watchPropertySpy1).toHaveBeenCalled();
        expect(watchPropertySpy2).toHaveBeenCalled();
        watchSpyRoot.reset();
        watchPropertySpy1.reset();
        watchPropertySpy2.reset();
        $scope1.safe = 'as grousers';
        $scope1.$digest();
        jasmine.Clock.tick(1);
        expect(watchSpyRoot).not.toHaveBeenCalled();
        expect(watchPropertySpy1).toHaveBeenCalled();
        expect(watchPropertySpy2).toHaveBeenCalled();
        watchSpyRoot.reset();
        watchPropertySpy1.reset();
        watchPropertySpy2.reset();
        jasmine.Clock.tick(1);
        expect(watchSpyRoot).not.toHaveBeenCalled();
        expect(watchPropertySpy1).not.toHaveBeenCalled();
        return expect(watchPropertySpy2).not.toHaveBeenCalled();
      });
      it('should remove watchers when one of the scopes is destroyed', function() {
        var $parentScope, $scope, watchParentSpy, watchSpy;
        $parentScope = $rootScope.$new();
        $scope = $rootScope.$new();
        $compose.compose($scope, $parentScope, 'child');
        watchParentSpy = jasmine.createSpy('watchParentSpy');
        watchSpy = jasmine.createSpy('watchSpy');
        $parentScope.$watch(watchParentSpy);
        $parentScope.$watch(watchSpy);
        jasmine.Clock.tick(1);
        watchParentSpy.reset();
        watchSpy.reset();
        $scope.$destroy();
        expect($parentScope.child).toBeUndefined();
        $scope.name = "something";
        $scope.$digest();
        expect(watchSpy).not.toHaveBeenCalled();
        return expect(watchParentSpy).not.toHaveBeenCalled();
      });
      it('should fire an error when a composed scope is totally overwritten', function() {
        var $parentScope, $scope, watchParentSpy, watchSpy;
        $parentScope = $rootScope.$new();
        $scope = $rootScope.$new();
        $compose.compose($scope, $parentScope, 'child');
        watchParentSpy = jasmine.createSpy('watchParentSpy');
        watchSpy = jasmine.createSpy('watchSpy');
        $parentScope.$watch(watchParentSpy);
        $parentScope.$watch(watchSpy);
        jasmine.Clock.tick(1);
        watchParentSpy.reset();
        watchSpy.reset();
        $parentScope.child = null;
        $parentScope.$digest();
        return expect($exceptionHandler.errors.length).toBe(1);
      });
      it('should not trigger a cycle when a scope is attached to the root scope', function() {
        var $scope, watchPropertySpy, watchRootPropertySpy, watchRootSpy, watchSpy;
        $scope = $rootScope.$new();
        $scope.meal = {
          pizza: 'for lunch'
        };
        watchSpy = jasmine.createSpy('watchSpy');
        watchRootSpy = jasmine.createSpy('watchRootSpy');
        $scope.$watch(watchSpy);
        $rootScope.$watch(watchRootSpy);
        jasmine.Clock.tick(1);
        watchSpy.reset();
        watchRootSpy.reset();
        $compose.compose($scope, $rootScope, 'meal');
        jasmine.Clock.tick(5);
        expect(watchSpy.calls.length).toBe(2);
        expect(watchRootSpy.calls.length).toBe(2);
        watchPropertySpy = jasmine.createSpy('watchPropertySpy');
        watchRootPropertySpy = jasmine.createSpy('watchRootPropertySpy');
        $scope.$watch('meal.pizza', watchPropertySpy);
        $rootScope.$watch('meal.pizza', watchRootPropertySpy);
        jasmine.Clock.tick(1);
        watchPropertySpy.reset();
        watchRootPropertySpy.reset();
        $scope.meal.pizza = 'for dinner';
        $scope.$digest();
        jasmine.Clock.tick(5);
        expect(watchPropertySpy).toHaveBeenCalled();
        return expect(watchRootPropertySpy).toHaveBeenCalled();
      });
      return it('should not trigger a cycle when a property is attached to the root scope', function() {
        var $scope, watchPropertySpy, watchRootPropertySpy, watchRootSpy, watchSpy;
        $scope = $rootScope.$new();
        $scope.user = {
          name: 'John Smith'
        };
        watchSpy = jasmine.createSpy('watchSpy');
        watchRootSpy = jasmine.createSpy('watchRootSpy');
        $scope.$watch(watchSpy);
        $rootScope.$watch(watchRootSpy);
        jasmine.Clock.tick(1);
        watchSpy.reset();
        watchRootSpy.reset();
        $compose.composeProperty($scope, 'user', $rootScope, 'user');
        jasmine.Clock.tick(5);
        expect(watchSpy.calls.length).toBe(2);
        expect(watchRootSpy.calls.length).toBe(2);
        watchPropertySpy = jasmine.createSpy('watchPropertySpy');
        watchRootPropertySpy = jasmine.createSpy('watchRootPropertySpy');
        $scope.$watch('user.name', watchPropertySpy);
        $rootScope.$watch('user.name', watchRootPropertySpy);
        jasmine.Clock.tick(1);
        watchPropertySpy.reset();
        watchRootPropertySpy.reset();
        $scope.user.name = 'Jane Smith';
        $scope.$digest();
        jasmine.Clock.tick(5);
        expect(watchPropertySpy).toHaveBeenCalled();
        return expect(watchRootPropertySpy).toHaveBeenCalled();
      });
    });
    return describe('$serviceScope', function() {
      var $serviceScope;
      $serviceScope = null;
      beforeEach(inject(function(_$serviceScope_) {
        return $serviceScope = _$serviceScope_;
      }));
      it('should correctly $update when the types are different', function() {
        var $scope;
        $scope = $serviceScope();
        $scope.$update('abc', 123);
        expect($scope.abc).toBe(123);
        $scope.$update('abc', 'hello');
        expect($scope.abc).toBe('hello');
        $scope.$update('abc', {
          a: 'b'
        });
        expect($scope.abc).toEqual({
          a: 'b'
        });
        $scope.$update('abc', [1, 2, 3]);
        expect($scope.abc).toEqual([1, 2, 3]);
        $scope.$update('abc', null);
        return expect($scope.abc).toBe(null);
      });
      it('should merge two objects without replacing the original one', function() {
        var $scope, ab;
        $scope = $serviceScope();
        ab = {
          a: 'b'
        };
        $scope.abc = ab;
        $scope.$update('abc', {
          a: 'c',
          b: 'd'
        });
        expect($scope.abc).toEqual({
          a: 'c',
          b: 'd'
        });
        return expect($scope.abc).toBe(ab);
      });
      it('should merge two arrays without replacing the original one', function() {
        var $scope, orig;
        $scope = $serviceScope();
        orig = [1, 2, 3];
        $scope.abc = orig;
        $scope.$update('abc', [4, 5, 6]);
        expect($scope.abc).toEqual([4, 5, 6]);
        return expect($scope.abc).toBe(orig);
      });
      it('should merge deep properties of objects', function() {
        var $scope, orig;
        $scope = $serviceScope();
        orig = {
          a: {
            b: 'c'
          }
        };
        $scope.abc = orig;
        $scope.$update('abc', {
          a: {
            b: 'd',
            c: 'e'
          }
        });
        expect($scope.abc).toEqual({
          a: {
            b: 'd',
            c: 'e'
          }
        });
        expect($scope.abc).toBe(orig);
        return expect($scope.abc.a).toBe(orig.a);
      });
      return it('should ignore properties starting with $', function() {
        var $scope;
        $scope = $serviceScope();
        $scope.abc = {
          $private: 'a',
          b: 'c'
        };
        $scope.$update('abc', {
          b: 'd'
        });
        return expect($scope.abc).toEqual({
          $private: 'a',
          b: 'd'
        });
      });
    });
  });

}).call(this);
