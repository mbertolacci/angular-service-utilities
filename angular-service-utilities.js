// Generated by CoffeeScript 1.3.3

/*
Exports

	compose($srcScope, $dstScope, name): 
		Sets $dstScope[name] = $srcScope and sets up two-way data binding.

	composeProperty($srcScope, property, $dstScope, name):
		Sets $dstScope[name] = $srcScope[property] and sets up two-way data binding.
*/


(function() {
  var debounce, digestOnceOnNextTick, mergeObject, qFactory,
    __slice = [].slice;

  angular.module('serviceUtilities', []).factory('$compose', [
    '$rootScope', function($rootScope) {
      var exports;
      return exports = {
        compose: function($srcScope, $dstScope, name) {
          var removeOurWatcher, removeTheirWatcher, removeWatchers, removeWatchersAndBreakLink;
          if ($dstScope.$id !== $rootScope.$id) {
            removeTheirWatcher = $dstScope.$watch(function() {
              if ($srcScope !== $dstScope[name]) {
                throw Error('$dstScope was detached from scope');
                return removeWatchers();
              } else {
                if ($dstScope.$$digestSource === $srcScope.$id) {
                  return;
                }
                return digestOnceOnNextTick($srcScope, $dstScope.$id);
              }
            });
          }
          removeOurWatcher = $srcScope.$watch(function() {
            if ($srcScope.$$digestSource === $dstScope.$id || $srcScope.$$digestSource === $srcScope.$id) {
              return;
            }
            return digestOnceOnNextTick($dstScope, $srcScope.$id);
          });
          removeWatchers = function() {
            removeTheirWatcher();
            return removeOurWatcher();
          };
          removeWatchersAndBreakLink = function() {
            removeWatchers();
            return $dstScope[name] = void 0;
          };
          $srcScope.$on('$destroy', removeWatchersAndBreakLink);
          $dstScope.$on('$destroy', removeWatchersAndBreakLink);
          $dstScope[name] = $srcScope;
          digestOnceOnNextTick($dstScope, $srcScope.$id);
          return exports;
        },
        composeProperty: function($srcScope, property, $dstScope, name) {
          var removeOurWatcher, removeTheirWatcher, removeWatchers, removeWatchersAndBreakLink;
          if ($dstScope.$id !== $rootScope.$id) {
            removeTheirWatcher = $dstScope.$watch(function() {
              $srcScope[property] = mergeObject($dstScope[name], $srcScope[property]);
              if ($dstScope.$$digestSource === $srcScope.$id) {
                return;
              }
              return digestOnceOnNextTick($srcScope, $dstScope.$id);
            });
          }
          removeOurWatcher = $srcScope.$watch(function() {
            $dstScope[name] = mergeObject($srcScope[property], $dstScope[name]);
            if ($srcScope.$$digestSource === $dstScope.$id || $srcScope.$$digestSource === $srcScope.$id) {
              return;
            }
            return digestOnceOnNextTick($dstScope, $srcScope.$id);
          });
          removeWatchers = function() {
            if (typeof removeTheirWatcher === "function") {
              removeTheirWatcher();
            }
            return removeOurWatcher();
          };
          removeWatchersAndBreakLink = function() {
            removeWatchers();
            return $dstScope[name] = void 0;
          };
          $srcScope.$on('$destroy', removeWatchersAndBreakLink);
          $dstScope.$on('$destroy', removeWatchersAndBreakLink);
          $dstScope[name] = $srcScope[property];
          digestOnceOnNextTick($dstScope, $srcScope.$id);
          return exports;
        }
      };
    }
  ]);

  /*
  Exports a factory function returning a service scope.
  */


  angular.module('serviceUtilities').factory('$serviceScope', [
    '$rootScope', '$serviceQ', '$compose', function($rootScope, $serviceQ, $compose) {
      return function() {
        var $serviceScope, promises;
        $serviceScope = $rootScope.$new(true);
        promises = {};
        $serviceScope.$get = function(name) {
          return promises[name].then(function() {
            return $serviceScope[name];
          });
        };
        $serviceScope.$defer = function(name) {
          var deferred;
          deferred = $serviceQ.defer();
          promises[name] = deferred.promise.then(function(actualValue) {
            $serviceScope[name] = actualValue;
            return digestOnceOnNextTick($serviceScope);
          });
          return deferred;
        };
        $serviceScope.$update = function(name, value) {
          return $serviceScope[name] = mergeObject(value, $serviceScope[name]);
        };
        $serviceScope.$attachProperty = function(property, $scope, name) {
          $compose.composeProperty($serviceScope, property, $scope, name);
          return $serviceScope;
        };
        $serviceScope.$attach = function($scope, name) {
          $compose.compose($serviceScope, $scope, name);
          return $serviceScope;
        };
        return $serviceScope;
      };
    }
  ]);

  angular.module('serviceUtilities').factory('$serviceQ', [
    '$exceptionHandler', function($exceptionHandler) {
      return qFactory(function(callback) {
        return setTimeout(callback, 0);
      }, $exceptionHandler);
    }
  ]);

  debounce = function(fn) {
    var timeout;
    timeout = null;
    return function() {
      var args, context;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      context = this;
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        timeout = null;
        return fn.call.apply(fn, [context].concat(__slice.call(args)));
      }, 0);
      return null;
    };
  };

  mergeObject = function(src, dst) {
    if (src === dst) {
      return dst;
    }
    if ((!angular.isArray(src) && !angular.isObject(src)) || (!angular.isArray(dst) && !angular.isObject(dst))) {
      return src;
    }
    if (angular.isUndefined(dst)) {
      return src;
    }
    angular.forEach(src, function(value, key) {
      if ((typeof key.charAt === "function" ? key.charAt(0) : void 0) === '$') {
        return;
      }
      return dst[key] = mergeObject(value, dst[key]);
    });
    if (angular.isArray(dst) && angular.isArray(src)) {
      dst.length = src.length;
    } else {
      angular.forEach(dst, function(value, key) {
        if ((typeof key.charAt === "function" ? key.charAt(0) : void 0) === '$') {
          return;
        }
        if (angular.isUndefined(src[key])) {
          return delete dst[key];
        }
      });
    }
    return dst;
  };

  digestOnceOnNextTick = function($scope, source) {
    if (!($scope.$$digestOnceOnNextTick != null)) {
      $scope.$$digestOnceOnNextTick = debounce(function(source) {
        $scope.$$digestSource = source;
        $scope.$digest();
        return $scope.$$digestSource = null;
      });
    }
    return $scope.$$digestOnceOnNextTick(source);
  };

  /*
  The following code is copied from AngularJS in order to get promises that
  don't trigger $rootScope.$digest on being resolved
  
  (c) 2010-2012 Google, Inc. http://angularjs.org
  License: MIT
  
  Constructs a promise manager.
  
  @param {function(function)} nextTick Function for executing functions in the next turn.
  @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
  debugging purposes.
  @returns {object} Promise manager.
  */


  qFactory = function(nextTick, exceptionHandler) {
    /*
    	@ngdoc
    	@name ng.$q#defer
    	@methodOf ng.$q
    	@description
    	Creates a `Deferred` object which represents a task which will finish in the future.
    	
    	@returns {Deferred} Returns a new instance of deferred.
    */

    /*
    	@ngdoc
    	@name ng.$q#reject
    	@methodOf ng.$q
    	@description
    	Creates a promise that is resolved as rejected with the specified `reason`. This api should be
    	used to forward rejection in a chain of promises. If you are dealing with the last promise in
    	a promise chain, you don't need to worry about it.
    	
    	When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of
    	`reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via
    	a promise error callback and you want to forward the error to the promise derived from the
    	current promise, you have to "rethrow" the error by returning a rejection constructed via
    	`reject`.
    	
    	<pre>
    	promiseB = promiseA.then(function(result) {
    	// success: do something and resolve promiseB
    	//          with the old or a new result
    	return result;
    	}, function(reason) {
    	// error: handle the error if possible and
    	//        resolve promiseB with newPromiseOrValue,
    	//        otherwise forward the rejection to promiseB
    	if (canHandle(reason)) {
    	// handle the error and recover
    	return newPromiseOrValue;
    	}
    	return $q.reject(reason);
    	});
    	</pre>
    	
    	@param {*} reason Constant, message, exception or an object representing the rejection reason.
    	@returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.
    */

    /*
    	@ngdoc
    	@name ng.$q#when
    	@methodOf ng.$q
    	@description
    	Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.
    	This is useful when you are dealing with an object that might or might not be a promise, or if
    	the promise comes from a source that can't be trusted.
    	
    	@param {*} value Value or a promise
    	@returns {Promise} Returns a single promise that will be resolved with an array of values,
    	each value corresponding to the promise at the same index in the `promises` array. If any of
    	the promises is resolved with a rejection, this resulting promise will be resolved with the
    	same rejection.
    */

    var all, defaultCallback, defaultErrback, defer, ref, reject, when_;
    defaultCallback = function(value) {
      return value;
    };
    defaultErrback = function(reason) {
      return reject(reason);
    };
    /*
    	@ngdoc
    	@name ng.$q#all
    	@methodOf ng.$q
    	@description
    	Combines multiple promises into a single promise that is resolved when all of the input
    	promises are resolved.
    	
    	@param {Array.<Promise>} promises An array of promises.
    	@returns {Promise} Returns a single promise that will be resolved with an array of values,
    	each value corresponding to the promise at the same index in the `promises` array. If any of
    	the promises is resolved with a rejection, this resulting promise will be resolved with the
    	same rejection.
    */

    all = function(promises) {
      var counter, deferred, results;
      deferred = defer();
      counter = promises.length;
      results = [];
      if (counter) {
        angular.forEach(promises, function(promise, index) {
          return ref(promise).then((function(value) {
            if (index in results) {
              return;
            }
            results[index] = value;
            if (!--counter) {
              return deferred.resolve(results);
            }
          }), function(reason) {
            if (index in results) {
              return;
            }
            return deferred.reject(reason);
          });
        });
      } else {
        deferred.resolve(results);
      }
      return deferred.promise;
    };
    defer = function() {
      var deferred, pending, value;
      pending = [];
      value = void 0;
      deferred = void 0;
      deferred = {
        resolve: function(val) {
          var callbacks;
          if (pending) {
            callbacks = pending;
            pending = undefined;
            value = ref(val);
            if (callbacks.length) {
              return nextTick(function() {
                var callback, i, ii, _results;
                callback = void 0;
                i = 0;
                ii = callbacks.length;
                _results = [];
                while (i < ii) {
                  callback = callbacks[i];
                  value.then(callback[0], callback[1]);
                  _results.push(i++);
                }
                return _results;
              });
            }
          }
        },
        reject: function(reason) {
          return deferred.resolve(reject(reason));
        },
        promise: {
          then: function(callback, errback) {
            var result, wrappedCallback, wrappedErrback;
            result = defer();
            wrappedCallback = function(value) {
              try {
                return result.resolve((callback || defaultCallback)(value));
              } catch (e) {
                exceptionHandler(e);
                return result.reject(e);
              }
            };
            wrappedErrback = function(reason) {
              try {
                return result.resolve((errback || defaultErrback)(reason));
              } catch (e) {
                exceptionHandler(e);
                return result.reject(e);
              }
            };
            if (pending) {
              pending.push([wrappedCallback, wrappedErrback]);
            } else {
              value.then(wrappedCallback, wrappedErrback);
            }
            return result.promise;
          }
        }
      };
      return deferred;
    };
    ref = function(value) {
      if (value && value.then) {
        return value;
      }
      return {
        then: function(callback) {
          var result;
          result = defer();
          nextTick(function() {
            return result.resolve(callback(value));
          });
          return result.promise;
        }
      };
    };
    reject = function(reason) {
      return {
        then: function(callback, errback) {
          var result;
          result = defer();
          nextTick(function() {
            return result.resolve((errback || defaultErrback)(reason));
          });
          return result.promise;
        }
      };
    };
    when_ = function(value, callback, errback) {
      var done, result, wrappedCallback, wrappedErrback;
      result = defer();
      done = void 0;
      wrappedCallback = function(value) {
        try {
          return (callback || defaultCallback)(value);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      wrappedErrback = function(reason) {
        try {
          return (errback || defaultErrback)(reason);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      nextTick(function() {
        return ref(value).then((function(value) {
          if (done) {
            return;
          }
          done = true;
          return result.resolve(ref(value).then(wrappedCallback, wrappedErrback));
        }), function(reason) {
          if (done) {
            return;
          }
          done = true;
          return result.resolve(wrappedErrback(reason));
        });
      });
      return result.promise;
    };
    return {
      defer: defer,
      reject: reject,
      when: when_,
      all: all
    };
  };

}).call(this);
